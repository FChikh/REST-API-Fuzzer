"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var path = require("path");
var devEnvInstaller = require("dev-env-installer");
var cp = require("child_process");
var index = require("./index");
var gitConfig = require("parse-git-config");
var gitBranch = require("git-branch");
function rootDir(currentDir) {
    var rootDir = currentDir;
    while (!fs.existsSync(path.resolve(rootDir, "package.json"))) {
        rootDir = path.resolve(rootDir, "../");
    }
    return rootDir;
}
exports.rootDir = rootDir;
function configureSecurity(homeDir) {
    var TRAVIS_KEY_PUBLIC = process.env.TRAVIS_KEY_PUBLIC;
    var TRAVIS_KEY_PRIVATE = process.env.TRAVIS_KEY_PRIVATE;
    if (TRAVIS_KEY_PUBLIC && TRAVIS_KEY_PRIVATE) {
        console.log("home dir: " + homeDir);
        var sshDir = path.resolve(homeDir, ".ssh");
        if (!fs.existsSync(sshDir)) {
            fs.mkdirSync(sshDir);
        }
        var keyPrivate = path.resolve(sshDir, "id_rsa");
        var keyPublic = path.resolve(sshDir, "id_rsa.pub");
        var privateKeyFormatted = "\n";
        for (var i = 0; i < TRAVIS_KEY_PRIVATE.length; i += 64) {
            var ind = Math.min(i + 64, TRAVIS_KEY_PRIVATE.length);
            privateKeyFormatted += TRAVIS_KEY_PRIVATE.substring(i, ind);
            privateKeyFormatted += "\n";
        }
        var keyPrivateContent = "-----BEGIN RSA PRIVATE KEY-----" + privateKeyFormatted + "-----END RSA PRIVATE KEY-----\n";
        var keyPublicContent = "ssh-rsa " + TRAVIS_KEY_PUBLIC + " RSA-1024\n";
        console.log("private key file: " + keyPrivate);
        console.log("public key file: " + keyPublic);
        fs.writeFileSync(keyPrivate, keyPrivateContent);
        fs.writeFileSync(keyPublic, keyPublicContent);
        fs.chmodSync(keyPrivate, 16832);
        fs.chmodSync(keyPublic, 16832);
    }
}
exports.configureSecurity = configureSecurity;
function setSSHUrl(workingDir) {
    var cfg = gitConfig.sync({ cwd: workingDir, path: '.git/config' });
    var gitUrl = cfg && cfg["remote \"origin\""] && cfg["remote \"origin\""].url;
    if (!gitUrl) {
        console.log("exit 0");
        return;
    }
    if (gitUrl.indexOf("@") > 0) {
        return;
    }
    var ind = gitUrl.lastIndexOf("/");
    if (ind < 0) {
        return;
    }
    ind = gitUrl.lastIndexOf("/", ind - 1);
    if (ind < 0) {
        return;
    }
    var repoName = gitUrl.substring(ind + 1);
    if (repoName.length >= ".git".length) {
        ind = repoName.lastIndexOf(".");
        if (ind >= 0) {
            if (repoName.substring(ind) == ".git") {
                repoName = repoName.substring(0, ind);
            }
        }
    }
    var repoSlug = repoName; //process.env.TRAVIS_REPO_SLUG;
    console.log("Repo slug: " + repoSlug);
    if (!repoSlug) {
        console.log("exit 4");
        return;
    }
    var command = "git remote set-url origin git@github.com:" + repoSlug + ".git";
    console.log("working dir: " + workingDir);
    console.log("set URL command: " + command);
    devEnvInstaller.utils.execProcess(command, workingDir, true);
}
exports.setSSHUrl = setSSHUrl;
function setGitUser(workingDir) {
    var email = process.env.GITHUB_EMAIL;
    if (email) {
        devEnvInstaller.utils.execProcess("git config --global user.email \"" + email + "\"", workingDir, true);
    }
    var name = process.env.GITHUB_USERNAME;
    if (name) {
        devEnvInstaller.utils.execProcess("git config --global user.name \"" + name + "\"", workingDir, true);
    }
}
exports.setGitUser = setGitUser;
function contributeTheStorage(workingDir, paths, messageOrFileName, messageFromFile) {
    if (messageFromFile === void 0) { messageFromFile = false; }
    console.log("message or filename: " + messageOrFileName);
    console.log("workingDir: " + messageOrFileName);
    console.log("paths:\n" + paths.join('\n'));
    var rd = workingDir;
    paths.forEach(function (p) {
        var addFilesCommand = "git add " + p;
        devEnvInstaller.utils.execProcess(addFilesCommand, rd, true);
    });
    var commitCommand;
    if (messageFromFile) {
        commitCommand = "git commit -F \"" + messageOrFileName + "\"";
    }
    else {
        commitCommand = "git commit -m \"" + messageOrFileName + "\"";
    }
    devEnvInstaller.utils.execProcess(commitCommand, rd, true);
    var pushCommand = "git push origin HEAD:master";
    devEnvInstaller.utils.execProcess(pushCommand, rd, true);
}
exports.contributeTheStorage = contributeTheStorage;
function extractValueFromTravisCommitMessage(tag) {
    var commitMessage = process.env[index.TRAVIS_COMMIT_MESSAGE];
    if (!commitMessage) {
        return null;
    }
    var ind = commitMessage.indexOf(tag);
    if (ind < 0) {
        return null;
    }
    ind += tag.length;
    var ind2 = commitMessage.indexOf("\n", ind);
    if (ind2 < 0) {
        ind2 = commitMessage.length;
    }
    var value = commitMessage.substring(ind, ind2);
    if (value.length > 0 && value.charAt(0) == "=") {
        value = value.substring(1).trim();
    }
    if (value.length == 0) {
        return null;
    }
    return value;
}
exports.extractValueFromTravisCommitMessage = extractValueFromTravisCommitMessage;
function cloneRepository(dir, uri, params) {
    var paramStr = "";
    if (params) {
        Object.keys(params).forEach(function (x) {
            var val = params[x];
            paramStr += ' ';
            paramStr += x;
            if (val != null) {
                if (val.length > 0 && val.charAt(0) != "=") {
                    paramStr += " ";
                }
                paramStr += val;
            }
        });
    }
    var command = "git clone " + uri + paramStr;
    devEnvInstaller.utils.execProcess(command, dir, true);
}
exports.cloneRepository = cloneRepository;
function checkoutCommit(dir, commitId) {
    var command = "git checkout " + commitId;
    devEnvInstaller.utils.execProcess(command, dir, true);
}
exports.checkoutCommit = checkoutCommit;
function getLastCommitId(wrkDir) {
    var command = "git log --format=\"%H\" -n 1";
    var logObj = cp.execSync(command, {
        cwd: wrkDir,
        encoding: 'utf8'
    });
    var result = logObj.toString().trim();
    return result;
}
exports.getLastCommitId = getLastCommitId;
function isWindows() {
    var osId = process.platform;
    return osId.indexOf("win") == 0;
}
exports.isWindows = isWindows;
function deleteFolderRecursive(folder) {
    if (fs.existsSync(folder)) {
        if (fs.lstatSync(folder).isSymbolicLink()) {
            fs.unlinkSync(folder);
            return;
        }
        fs.readdirSync(folder).forEach(function (fileName) {
            var childPath = path.join(folder, fileName);
            if (fs.lstatSync(childPath).isDirectory()) {
                deleteFolderRecursive(childPath);
            }
            else {
                fs.unlinkSync(childPath);
            }
        });
        fs.rmdirSync(folder);
    }
}
exports.deleteFolderRecursive = deleteFolderRecursive;
;
function insertDummyChanges(rootDir, fileName) {
    var triggerFilePath = path.resolve(rootDir, fileName);
    var triggerFileContent = fs.readFileSync(triggerFilePath, "utf-8");
    var triggerFileContentTrim = triggerFileContent.trim();
    if (triggerFileContent == triggerFileContentTrim) {
        triggerFileContent = triggerFileContent + " ";
    }
    else {
        triggerFileContent = triggerFileContentTrim;
    }
    fs.writeFileSync(triggerFilePath, triggerFileContent);
}
exports.insertDummyChanges = insertDummyChanges;
function pluginBranch(pluginName, folderOrDescriptor, rootFolder) {
    var descriptor = folderOrDescriptor;
    if (fs.lstatSync(descriptor).isDirectory()) {
        descriptor = path.resolve(descriptor, "workspace.json");
    }
    if (!fs.existsSync(descriptor)) {
        return null;
    }
    rootFolder = rootFolder || path.dirname(descriptor);
    var modulesMap = devEnvInstaller.utils.loadModulesStaticInfo(descriptor);
    if (!modulesMap) {
        return null;
    }
    var moduleInfo = modulesMap[pluginName];
    if (!moduleInfo) {
        return null;
    }
    var branchName = moduleInfo.gitBranch;
    if (typeof branchName == "string") {
        return branchName;
    }
    var packagejsonfile = path.resolve(rootFolder, "package.json");
    if (!fs.existsSync(packagejsonfile)) {
        return null;
    }
    try {
        var packagejson = JSON.parse(fs.readFileSync(packagejsonfile, "utf8"));
        if (packagejson.name != pluginName) {
            return null;
        }
    }
    catch (e) {
        console.log(e);
        return null;
    }
    branchName = process.env.TRAVIS_BRANCH;
    if (branchName) {
        return branchName;
    }
    branchName = gitBranch.sync(rootFolder);
    if (typeof branchName == "string") {
        return branchName;
    }
    return null;
}
exports.pluginBranch = pluginBranch;
//# sourceMappingURL=impl.js.map